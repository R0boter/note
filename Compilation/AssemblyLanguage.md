## 汇编语言基础

---

### 常量(constant)

常量是程序使用的一个确定数值，直接编码于指令代码中，不是保存在存储器中的可变变量。正因为直接编码在指令代码中，所以它是和指令一起存储，不需要单独开辟存储空间，也就无法动态改变它的值。这正是高级语言中常量无法修改的原因。

1. 整数常量(integer literal)：又称整型常量(integer constant)，由一个可选的前置符号、一个或多个数字、以及一个指示其基数的可选基数字符组成`[{-|+}]digits[radix]`

   | 基数字符 |   含义   | 备用 |
   | :------: | :------: | :--: |
   |    H     | 十六进制 |      |
   |   Q/O    |  八进制  |      |
   |    D     |  十进制  |  T   |
   |    B     |  二进制  |  Y   |
   |    R     | 编码实数 |      |

   > **Tips:**以字符开头的十六进制数必须加个前置 0，防止汇编器将其解释为标识符

2. 整型常量表达式(constant integer expression)：包含了整数常量和算术运算符的算术表达式，，其计算结果一定是一个整数，并可用 32 位(0 到 FFFFFFFFH)存放

   | 运算符 |        名称        | 优先级 |
   | :----: | :----------------: | :----: |
   |   ()   |       圆括号       |   1    |
   |  +、-  | 一元加、减(正、负) |   2    |
   | \*、/  |       乘、除       |   3    |
   |  MOD   |     取模/取余      |   3    |
   |  +、-  |       加、减       |   4    |

   > **Tips:**在同一个包含多个运算符的表达式中优先级越高的运算符先进行运算，同级的按照先后进行运算
   >
   > **运算结果必须为整数**

3. 字符常量(character literal)：用引号包裹的单个字符，其在内存中保存的是该字符二进制`ASCII`码的数值(字符常量在内部保存为整数，所以使用的是`ASCII`编码序列)

   > 例：字符常量'A'在内存中的存放形式为数字 65 或 41H

4. 字符串常量(string literal)：用引号包裹的字符序列(包含空格符)

   > **Tips:**允许使用嵌套引号，如果要包含单引号，则整个字符串应该用双引号包裹，反之亦然。
   >
   > 字符串常量在内存中也是以整数字节数值序列，例如字符串常量'AB'就包含两个字节 41H、42H

### 保留字(reserved words)

定义：一些有特殊含义的字符且只能在其正确的上下文中使用。在汇编语言中保留字没有大小写之分

类型：

> 1. 指令助记符。如：`mov`、`ADD`、`MUL`
>
> 2. 寄存器名
>
> 3. 伪指令
>
> 4. 运算符。如在常量表达式中使用的运算符
>
> 5. 属性：提供变量和操作数的大小和使用信息。如：`BYTE`、`WORD`
>
> 6. 预定义符号。如：`@data`它在汇编是返回常量的整数值
>
>    **Tips:**汇编器不同保留字会有一些差别

### 标识符(identifier)

定义：用于标识变量、常数、子程序、代码标签，遵循一定规则的自定义字符

规则：

> 1. 可以包含 1 到 247 个字符
>
> 2. 不区分大小写
>
> 3. 第一个字符必须位字母、下划线、`@`、`?`、`$`中的任意一个。其后的字符可以是数字
>
> 4. 标识符不能和汇编器保留字相同
>
>    **Tips:**不建议使用下划线、`@`、`?`、`$`作为标识符的首字母

### 伪指令(directive)

定义：用于嵌入源代码中的汇编器命令，由汇编器识别和执行。通常用来定义变量、宏、子程序、为内存段分配名称以及执行其他与汇编器相关的日常认为。默认不区分大小写

### 汇编指令(instruction)

定义：由汇编器翻译位机器语言字节，并且在运行时由 CPU 加载和执行的语句

> 一条汇编指令由四部分组成：`[label:] mnemonic [operands] [;comment]`
>
> 1. 标号(可选)
> 2. 指令助记符(必需)
> 3. 操作数(通常时必需的)
> 4. 注释(可选)

#### 标号(label)

定义：标识符的一种，是指令和数据的位置标记。当标号位于指令的前端，就表示指令的地址；当标号位于变量的前端，就表示变量的地址

类型：数据标号和代码标号

> 1. 数据标号用于表示变量的位置，它提供一种方便的手段在代码中引用变量。一个数据标号后可以跟多个数据项，访问时可以使用`label[index]`的方式访问。数据标号不需要冒号结束
> 2. 代码标号用于当作跳转和循环指令的目标。代码标号只能出现在代码段中，且必须用冒号结尾。代码标号可以与指令在同一行，也可以独立存在一行。每个标号在其封闭的子程序页必须是唯一的，就可以多次使用同一标号

#### 指令助记符

定义：用于标识一条机器指令的短单词，是汇编指令中最重要的核心组成部分。

一些常用的助记符例子：

| 助记符 |          说明          |
| :----: | :--------------------: |
| `MOV`  |     传送(分配)数值     |
| `ADD`  |      两个数值相加      |
| `SUB`  | 从一个数值中减去另一个 |
| `MUL`  |      两个数值相乘      |
| `JMP`  |    跳转到另一个位置    |
| `CALL` |     调用一个子程序     |

#### 操作数

定义：操作数是指令输入输出的数字。汇编语言的操作数个数范围是 0~3 个。操作数可以是寄存器(reg/seg)、内存地址(mem)、立即数(imm)、整数表达式、输入输出端口中的一个或多个

> **Tips:**
>
> 1. 内存地址包括变量名、带方括号的寄存器名。内存地址也叫内存操作数
>
> 2. 操作数有固定的顺序，通常第一个操作数被称为目的操作数(destination operand)，第二个操作数被称为源操作数(source operand)。一般目的操作数的内容由指令修改
>
> > 例如：
> >
> > `inc ax`：`inc`指令有一个目的操作数`ax`
> >
> > `mov ax,bx`：`mov`指令有一个目的操作数`ax`和一个源操作数`bx`
> >
> > `imul eax,ebx,5`：`imul`指令有一个目的操作数`eax`和两个源操作数`ebx`、`5`

#### 注释

定义：注释是程序编写者与阅读者交流程序设计信息的重要途径。通常程序源码的开始部分包含以下信息

> 1. 程序的目的
> 2. 程序创建者和修改者名单
> 3. 程序的创建时间和修改时间
> 4. 程序实现技术的说明

注释有两种方法：

> 1. 单行注释：以分号`;`开始。汇编器将忽略同一行中分号之后的所有字符
> 2. 块注释：使用`COMMENT`伪指令和一个用户自定义符号开始，直到相同的用户自定义符号表示结束。汇编器将忽略两个自定义符号中间的所有字符

#### 空指令(NOP)

定义：在程序空间中占用一个字节，但不做任何操作。它有时被编译器和汇编器用于将代码对齐到有效的地址边界。

> **Tips:**
>
> 1. 最安全的指令就是`NOP`(空操作)，也是最无用的指令
> 2. x86 处理器被设计为从双字的偶数倍地址处加载代码和数据，所有当一条指令或数据占用的是三个字节时，利用`NOP`空操作指令来对齐地址边界，可以使加载速度更快

## 汇编指令

---

1. 汇编指令和寄存器名不区分大小写
2. 在进行数据传送或运算时，要注意指令的两个操作对象位数应该一致
3. 当汇编指令的操作对象为 8 位寄存器时，当操作结果数值超过 8 位时，多余 8 位的数据不能在 8 位寄存器中存放，也不会进位。例如：mov al,137H 因为 al 是 8 位寄存器，137H 超过 8 位所以最高位的 1 无法保存在 al 寄存器中，且此时的操作对象是 al 寄存器，是一个单独的寄存器，CPU 在执行这条指令时会认为 al 和 ah 是两个不同的寄存器，所以这条指令产生的进位不会存储在 ah 中。同理操作 16 位寄存器时，操作结果的值多余 16 位时，多出的数据也无法存放在寄存器中

### 数据传送指令(Data Transfer)

#### 通用数据传输指令

1. `mov`：在 CPU 内或 CPU 和内存之间传送字节或字。将源操作数复制到目的操作数。

   格式：`mov` destination,source

   允许的操作：

   1. `mov reg,Reg/Mem/Imm/Seg`
   2. `mov mem,Reg/Seg`
   3. `mov Seg,Reg/Mem`

   不允许的操作：

   1. `mov`指令中的两个操作数的类型必须一致，都为 8 位或 16 位。否则为非法指令
   2. `mov`指令中的 destination 绝对不能是 Imm 和 Code Segment
   3. `mov`指令中不允许在两个内存单元之间直接传送数据
   4. `mov`指令中不允许在两个段寄存器之间直接传送数据

   注意事项：

   1. `mov`指令不影响标志位
   2. `Imm`的值可以为十进制也可以为十六进制，一般为十六进制
   3. `mov`指令进行寄存器和内存之间的数据传送时，所传送的数据大小按使用的寄存器大小决定。使用 16 位寄存器则传送的是 16 位数据

2. push：首先减少堆栈指针寄存器中的值，再将源操作数复制到堆栈，当操作数是 16 位时，堆栈指针寄存器中的值减 2。当操作数是 32 位时，堆栈指针寄存器中的值减 4

   格式：`push source`

   允许的操作：`push reg/seg/mem`

3. `pop`：首先将当前指向的堆栈元素的内容传送到目的操作数中，再增加堆栈指针寄存器中的值，当操作数是 16 位时加 2，当操作数是 32 位时，堆栈指针寄存器中的值加 4

   格式：`pop destination`

   允许的操作：`pop reg/seg/mem`

#### 输入输出端口传送指令

#### 目标地址传送指令

#### 标志传送指令

### 算术运算指令

1. `add`：加法运算指令，用目的操作数中的值加上源操作数中的值，并将结果传送到目的操作数中

   格式：`add destination,source`

   允许的操作：

   1. `add reg,imm/reg/mem`
   2. `add mem,reg`

   不允许的操作：

   1. 段寄存器不能参与加法运算

2. `inc`：加法运算指令，指定的目的操作数进行自加一运算

   格式：`inc destination`

   允许的操作：`inc reg/mem`

3. `sub`：减法运算指令，用目的操作数中的值减去源操作数中的值，并将结果传送到目的操作数中

   格式：`sub destination,source`

   允许的操作：

   1. `sub reg,imm/reg/mem`
   2. `sub mem,reg`

   不允许的操作：

   1. 段寄存器不能参与减法运算

4. `div`：除法运算指令

   格式：`div destination`

   允许的操作：`div reg/mem`

   > **Tips:**
   >
   > 1. 除数：即目的操作数，分为 8 位和 16 位两种，在一个寄存器或内存单元中
   > 2. 被除数：如果除数为 8 位，则被除数为 16 位，默认放在 AX 中；如果除数为 16 位，则被除数为 32 位，默认放在 DX 和 AX 中，其中 DX 存放高 16 位，AX 存放低 16 位
   > 3. 结果：如果除数为 8 位，则商存储在 AL 中，余数存储在 AH 中；如果除数为 16 位，则商存储在 AX 中，余数存储在 DX 中

### 逻辑运算指令(位运算)

1. `and`：逻辑与指令，按位进行与运算。当且仅当两操作数对应位都为 1 时，结果的对应位为 1。否则结果的对应位为 0。常用于清零指定位

   格式：`and destination source`

2. `or`：逻辑或指令，按位进行或运算。当且仅当两操作数对应位都为 0 时，结果的对应位为 0.否则结果的对应位为 1.常常用于将指定位设 1

### 串指令

### 程序转移指令

#### 无条件转移(长转移)

1. `jmp`

   我们可以通过改变寄存器中的内容实现对 CPU 的控制，通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。mov 指令可以更改 8086CPU 中大部分寄存器的值，但不能设置 CS、IP 的值，能够改变 8086CPU 中 CS、IP 的内容的指令被统称为转移指令。

|         语法          |     示例     |                       说明                       |
| :-------------------: | :----------: | :----------------------------------------------: |
| `jmp 段地址:偏移地址` | `jmp 2AE3:3` | `CS=2AE3H`、`IP=0003H`，CPU 从 2AE33 处读取指令  |
| `jmp 某一合法寄存器`  |   `jmp ax`   | 用 ax 寄存器中的值修改 IP，含义类似于`mov IP,ax` |

#### 条件转移指令

#### 循环控制指令(短转移)

1. `loop`

   格式：`loop label`

   CPU 在执行`loop`指令时，会先将 cx 寄存器中的值减一，然后判断 cx 寄存器中的值是否为 0。若不为 0，则跳转到指定标号处执行程序。反之，则不跳转，继续向下执行。

#### 中断指令

#### 处理器控制指令

### 程序返回指令

一个可执行程序必须有一个正在运行的程序将这个可执行程序加载到内存中，并将 CPU 控制权交给这个可执行程序才可以运行

当这个可执行程序运行完成后，需要将 CPU 的控制权交还给将它加载到内存中的程序。

一个程序运行结束后，将 CPU 控制权交还给使它能够运行的程序的 这个过程就叫做**程序返回**

```assembly
assume cs:codesg
codesg segment
   mov ax,2
   add ax,ax

   mov ax,4c00H   ; 配合int 21H实现程序返回
   int 21H        ; 程序返回，必须是这两行指令
codesg ends
end
```

## 伪指令

---

在汇编语言源程序中包含两种指令，一种时汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译成机器指令，最终被**CPU 执行**。而伪指令没有对应的机器指令，是由**编译器执行**的指令，编译器根据伪指令来进行相关的编译工作

### 操作符

`byte ptr`：在没有寄存器名存在的情况下，用操作符`byte ptr`指明内存单元为一个字节单元，长度为 1byte(8 位)

`word ptr`：在没有寄存器名存在的情况下，用操作符`word ptr`指明内存单元为一个字单元，长度为 2byte(16 位)

```assembly
; 指明指令访问的内存单元为字节单元
mov byte ptr ds:[0],1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx],2

; 指明指令访问的内存单元为字单元
mov word ptr ds:[0],1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx],2

```

> **Tips:**
>
> 1. 当指令中存在寄存器时，进行处理的数据的长度由寄存器大小决定
>
> 2. 有些指令默认了进行操作时访问的是字单元还是字节单元
>
>    例如：`push [1000H]`就不要指明访问的是字单元还是字节单元，因为`push`指令只进行字操作

`dup`：配合`db、dw、dd`等定义数据的伪指令一起使用，用来进行数据的重复

```assembly
; 使用格式如下
; db 重复的次数 dup （重复的字节型数据）
; dw 重复的次数 dup （重复的字型数据）
; dd 重复的次数 dup （重复的双字型数据）

; 示例如下
dd 4 dup 2       ; 定义了四个双字型数据，每个数据都是2。总长度为16字节
dw 2 dup (3,5,1) ; 定义了6个字型数据，分别是3、5、1、3、5、1，总长度为12字节
db 3 dup ('abc','ABC') ; 定义了18个字节。分别是'abcABCabcABCabcABC'，总长度18字节
```

> **Tips:**`dup`常被用于定义栈段，开辟空间

### 定义数据

`db`：定义字节型数据，每个数据用逗号分隔。每个数据占一个字节的空间。定义的数据所占的总内存空间等于数据个数的字节数

`dw`(define word)：定义字型数据，每个数据用逗号分隔。每个数据占一个字的空间。定义的数据所占的总内存空间等于数据个数乘以二个字节

```assembly
assume cs:code
code segment
dw 1230H,234aH,0dbcH,03a8H ;定义四个字型数据,因为在代码段的头部定义的，所以可以从CS段寄存器中获取它们的段地址。访问时可以用CS:0、CS:2、CS:4、CS:6来进行访问。
code ends
end
```

`dd`：定义双字型数据，每个数据用逗号分隔。每个数据占两个字的空间。定义的数据所占的总内存空间等于数据个数乘以四个字节

### 关联

`assume`指令将 CPU 中的段寄存器和源程序中定义的段相关联，为源程序中定义的段指定默认的段寄存器

```assembly
assume cs:codesg  ; 将定义的codesg段和CS段寄存器相关联，所以定义的codesg段会作为代码段使用
codesg segment
   :
   :
codesg ends
end
```

### 段定义和段结束

一个汇编程序由多个段组成，这些段被用来存放代码、数据、当作栈空间来使用。一个汇编源程序中所有将被计算机处理的信息：指令、数据、栈。在这个源程序中被划分到不同的段中

一个汇编源程序至少由一个段组成，这个段被用来存放代码

```assembly
segmentName segment  ; 定义一个段，段命为segmentName
   :
   :
segmentName ends  ; 定义segmentName段结束
```

### 结束和开始

汇编程序中的结束标记为`end`，当编译器在编译汇编源程序时，如果碰到伪指令`end`，就结束编译。必须在汇编源程序结尾处 加上`end`伪指令，否则编译器无法知道程序在何处结束

结束标记还可以用来指定程序入口：`end label`。在源程序中指定哪一条指令作为第一条要执行的指令，在指定的指令处设置一个标号，在源程序中用`end`后面跟指定的第一条执行的指令前的标号，就可以用来确定程序入口

> **Tips**：注意区别`end`伪指令和`ends`伪指令，`end`是用于表示程序的结束，而`ends`是用于表现定义的段的结束

## 标号

## 其他符号

---
