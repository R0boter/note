## 机器语言

定义：机器语言是机器指令的集合。

机器指令是一列二进制数字，计算机将它转换成一列高低电平使计算机的电子器件受到驱动，进行运算。现代常用的PC机由CPU来完成这种功能，CPU是一种微处理器。CPU和其他受CPU直接或间接控制的芯片、器件、设备组成了计算机系统

每一种微处理器由于硬件设计和内部结构不同，就需要不同的电平脉冲来控制，使他工作。所以每一种微处理器都有自己的机器指令

## 汇编语言

汇编语言是的主体是汇编指令，汇编指令和机器指令的区别在指令的表示方法，汇编指令是机器指令便于记忆的书写格式。利用汇编指令写好的程序由汇编编译器转换成机器码

汇编语言由三类指令组成：

1. 汇编指令：机器码的助记符，有对应的机器码。是汇编语言的核心所在，它决定了汇编语言的特性

2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行

3. 其他符号：如`+`、`-`、`*`、`/`等，由编译器识别，没有对应的机器码

## 指令和数据，存储器和存储单元

指令和数据是应用上的概念，在内存或磁盘上指令和数据没有任何区别，都是二进制信息。CPU在工作时会把有的信息看作指令有的看作数据

> 在8086CPU中，任何时候CPU都将CS、IP中的内容当作指令的段地址和偏移地址，用他们合成指令的物理地址，到内存中读取指令码。所以在8086CPU中将CS:IP指向的内存单元中的内容看作指令

要让CPU正常工作就必须向它提供指令和数据，而指令和数据必须存放在存储器中。一般存储器是指内存而不是磁盘，因为磁盘和内存是不相同的，CPU无法从磁盘上读取数据，只能将指令和数据先存放在内存中，CPU再从内存中读取指令和数据。

存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。

电子计算机的最小信息单位为bit，即一个二进制位。8bit组成1Byte(字节)。而微型机存储器的存储单元可以存储1Byte。所以微型存储器的容量是以字节为最小单位来计算拥有N个存储单元的存储器，容量为N个字节

> Tips： 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024B 1B=8bit
>
> 2^10=1024;2^20=1024x1024;2^30=1024x1024x1024

## CPU对存储器的读写

在一台微机中不止由存储器一种器件，CPU在读写数据时还要指明它要对哪一个器件进行操作，是读取操作还是写入操作

CPU要进行数据的读写，必须和外部器件(芯片)进行3类操作：

> 存储单元的地址 --> 地址信息
>
> 器件的选择，读取还是写如操作 --> 控制信息
>
> 读取或写入的数据 --> 数据信息

## 总线

总线从物理层面，总线是CPU连接其他芯片的一根根导线的集合。

根据总线位置不同分为两类：

> 内部总线：连接CPU内部的运算器，控制器和寄存器等
>
> 外部总线：连接CPU和主板上其他器件

根据传送信息的不同，总线从逻辑上又分为三类：

> 地址总线：发送地址信息，用于寻址
>
> 控制总线：发送控制信息，选中指定的存储器芯片，并通知它要进行的操作
>
> 数据总线：发送或接受数据信息，即控制信息中要写入还是读取的数据

### 1. 地址总线

地址总线指CPU所有地址导线的集合。地址总线表现了CPU的寻址能力，一根导线可以传送的稳定状态只有两种，高电平和低电平，用二进制的1和0表示

N根地址导线可以传送N位二进制数据，N位二进制数据最多可以表示2的N次方个不同数据，最小为0，最大为2^N-1

一个CPU有N根地址线，则这个CPU地址总线宽度为N。这个CPU最多可以寻找2^N个内存单元，一个存储单元能储存1个字节，所以这个CPU的寻址能力为2^N个字节

> 例子：
>
> 一个有10根总线的CPU，其地址总线宽度为10，最多可寻找1024个内存单元，内存单元从0开始顺序编号，0到1023号内存单元。这个CPU的寻址能力为2^10字节=1024B=1KB
>
> 一个有20根总线的CPU，其地址总线宽度为20，最多可寻找1048576个内存单元，这个CPU的寻址能力为2^20字节=2^20B=2^10KB=1MB

### 2. 数据总线

CPU与内存或其他器件之间的数据传送是通过数据总线进行的，数据总线的宽度决定了数据的传输速度，一根数据总线一次只能传送一个二进制数据，8根数据总线一次可传送8位二进制数据，即1Byte，16根则可以传送两个字节

### 3. 控制总线

控制总线是不同控制导线的集合，有多少根控制总线，CPU就提供可对外部器件的多少种控制，所以控制总线的宽度决定了CPU对外部器件的控制能力

控制总线中有一根为*读信号输出*负责由CPU向外传送读信号，CPU向该控制线输出低电平表示将要读取数据;有一根为*写信号输出*负责传送写信号

## 主板、接口卡和各类存储器芯片

主板上有核心器件和一些主要器件，这些器件通过总线(地址总线、控制总线、数据总线)连接，这些器件包括CPU、存储器、外围芯片组、扩展插槽(扩展插槽一般插RAM内存条或其他接口卡[显卡、声卡、网卡])

CPU对外部设备不能直接控制，如显示器、音箱、打印机等。直接控制这些设备的时扩展插槽上的接口卡，CPU通过总线直接控制接口卡，接口卡直接控制外设。即CPU通过总线向接口卡发送命令，接口卡根据CPU命令控制外设工作

一台PC机装有多个存储芯片，从物理连接来看每个存储器芯片都是独立的、不同的器件，从读写属性来看分为两类：随机存储器(RAM)和只读存储器(ROM)

> 随机存储器可读可写，但必须带电存储，断电后数据丢失。
>
> 只读存储器只能读取不能写入，断电后数据不丢失

从功能和连接可分为以下几类：

> 主随机存储器：由装在主板上的RAM和插在扩展插槽上的RAM组成。用于存放CPU要使用的绝大部分程序和数据
>
> 接口卡上的RAM：某些接口卡需要对大批量的输入输出数据进行暂时存储，在其上就装有RAM，如显存，CPU将需要显示的数据写入到显存，显示卡将显存中的数据向显示器输出
>
> 装有BIOS(Basic Input/Output System)的ROM：BIOS是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件进行最基本的输入输出。如主板上的BIOS，一般称为系统BIOS，显卡上的ROM存储着显卡的BIOS，网卡上的ROM存储着网卡的BIOS

上述存储器在物理上都是独立器件，但有两点相同：1.都和CPU的总线相连 2.CPU都通过控制总线发出内存读写命令对他们进行读取或写入

## 内存地址空间

概述： 对CPU来说系统中所有存储器中的存储单元都处于一个统一的逻辑存储器中，这个逻辑存储器就是计算机的内存地址空间，内存地址空间的大小受CPU地址总线宽度限制

CPU对所有存储器进行操作时，将这些在硬件上独立的存储器芯片看作是一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占一个地址段，CPU对相应的地址空间读写数据，实际上就是在相应的物理存储器中读写数据，这个逻辑存储器就是内存地址空间，汇编所主要面对的就是内存地址空间

基于计算机硬件系统编程必须知道系统中内存地址空间的分配情况，当对某类存储器进行读写操作时必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作时在预期的存储器中进行的。不同计算机系统的内存地址空间的分配情况时不同的。

8086CPU的内存地址分配情况如下：

> 0~7FFFH：32KB主存储地址空间(RAM)
> 8000H~9FFFH：8KB显存地址空间
> A000H~FFFFH：24KB各类ROM地址空间-向此处内存单元写入数据为无效操作，因为时只读存储器

## 寄存器

一个典型的CPU由运算器、控制器、寄存器等器件构成，由内部总线进行连接

> 运算器进行信息处理
>
> 寄存器进行信息存储
>
> 控制器进行各种器件进行工作
>
> 内部总线连接各种器件，在他们之间进行数据传送

寄存器是CPU中可以用指令读写的部件，通过改变寄存器中的内容实现对CPU的控制。不同CPU中寄存器的个数、结构是不同的。

8086CPU有14个寄存器，且每个CPU都是16位可以存放两个字节：

> 通用寄存器：AX、BX、CX、DX，用来存放一般性数据。SP、BP，指针寄存器。SI、DI，变址寄存器

1. 通用寄存器(General-Purpose Registers，GPRs)

   * AH&AL=AX(Accumulator)：累加寄存器，常用于运算。在乘除等指令中指定用来存放操作数，另外所有的I/O指令都使用这一寄存器与外部器件之间传送数据
   * BH&BL=BX(Base)：基地址寄存器，常用于地址索引
   * CH&CL=CX（Count)：计数寄存器，常用于计数，保存计算值，如在移位指令，循环(loop)和串处理指令中用作隐含的计数器
   * DH&DL=DX(Data)：数据寄存器，常用于数据传递。当使用DIV指令进行除法运算时，如果除数是16位，被除数将会是32位，而被除数的高16位就存放在DX中，同样在执行MUL指令时，如果两个相乘的数都是16位，那么相乘后产生的结果也需要32位来保存，而这32位结果的高16位就存放在DX寄存器中
   * SP(Stack Pointer)：堆栈指针寄存器，与SS配合可指向目前的堆栈位置
   * BP(Base Pointer)：基址指针寄存器，可用作SS的一个相对基址位置
   * SI(Source Index)：源变址寄存器，可用来存放相对于DS段的原变址指针
   * DI(Destination Index)：目的变址寄存器，可用来存放相对于ES段的目的变址指针

   > Tips1：前四个通用寄存器可以分为高八位AH、BH、CH、DH以及低八位AL、BL、CL、DL这两组八位寄存器可以分别寻址单独使用，当使用8位寄存器时，CPU会将这个8位寄存器当作一个独立的寄存器，如AL寄存器被单独使用时，AL和AH是两个不同的寄存器，当AL中的参与运算产生进位时不会存储在AH中，这时它参与的是8位运算
   >
   > Tips2：后四个通用寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址

2. 控制寄存器

   * IP(Instruction Pointer)：指令指针寄存器，这是一个16位的专用寄存器，它指向当前需要取出的指令字节。当BIU从内存中取出一个指令字节后，IP就自动加该字节的长度(取出1字节IP加一，取2字节IP加二)，并指向下一个指令字节。IP指向的指令地址的段内地址的**偏移量**，即**偏移地址**(Offset Address)或**有效地址**(EA，Effective Address)

   * FR(Flags Register)：标志寄存器，一种特殊寄存器(对于不同处理机，个数和结构都可能不同)，这种特殊寄存器在8086CPU中被称为标志寄存器，其中存储的信息通常被称为程序状态字(Program Status Word，PWS)。其他寄存器是用来存放数据的，都是整个寄存器有一个含义，FR寄存器是按位起作用的，它的每一位都有专门的含义，用于记录特定的信息

     | 15  | 14  | 13  | 12  | 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
     | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
     |     |     |     |     | OF  | DF  | IF  | TF  | SF  | ZF  |     | AF  |     | PF  | CF  |

   > Tips：8086CPU的FR寄存器中有意义的有9位，其中6位是状态位，3位是标志位

   * OF：溢出标志位，用于反应有符号数加减运算所得结果是否溢出。如果运算结果超出当前运算位数所能表示的范围，则溢出。OF的值为1，反之，为0

   * DF：方向标志位，用于决定在串操作指令执行时有关指针寄存器发生调整的方向

   * IF：中断允许标志位，用于决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求，但CPU必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求

     1. 当IF值为1时，CPU响应CPU外部的可屏蔽中断发出的中断请求
     2. 当IF值为2时，CPU不响应CPU外部的可屏蔽中断发出的中断请求

   * TF：跟踪标志位，该标志用于调试程序，但TF标志位没有专门指令用来设置或清除

     1. 当TF值为1时，CPU处于单步执行指令的工作模式，此时没执行完一条指令就显示CPU内各个寄存器的值以及CPU下一步要执行的指令

     2. 当TF值为2时，CPU处于连续工作模式

   * SF：符号标志位，用于反应运算结果的符号位，它和运算结果的最高位相同。运算结果为非负数，SF值为0。反之，SF值为1。

     1. 当运算结果没有产生溢出时，运算结果等于逻辑结果，SF表示的是逻辑结果的正负

     2. 当运算结果产生溢出时，运算结果不等于逻辑结果，SF表示的正负情况和逻辑结果相反

   * ZF：零标志位，用于反映运算结果是否为0。为0，ZF值为1。反之，ZF为0

   * AF：辅助进位标志位，当出现下列情况时其值为1，否则为0

     1. 在字(word)操作时，发生低字节向高字节进位或借位时

     2. 在字节(Byte)操作时，发生低四位像高四位进位或借位时

   * PF：奇偶标志位，用于反映运算结果中1的个数的奇偶性，如果1的个数为偶数，则PF的值为1，反之为0

   * CF：进位标志位，用于反映无符号数运算是否产生进位或借位，如果运算结果的最高位产生了一个进位或借位，其值为1。反之，为0

3. 段寄存器

   * CS(Code Segment)：代码段寄存器，和指令指针寄存器IP一起指示了CPU当前要读取的指令的地址。在8086CPU中任意时刻，CPU将`CS:IP`指向的内容当作指令来执行。

     8086CPU的工作流程为：

     1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器

     2. IP=IP+所读取指令的长度，从而指向下一条指令

     3. 执行指令，转到步骤(1)。重复过程

     > CPU是读取代码寄存器CS中的值作为段地址，读取指令指针寄存器IP中的值作为偏移地址
     >
     > 在8086CPU加电启动或复位后(即CPU刚开始工作)CS和IP的值被设置为`CS=FFFFH`，`IP=0000H`。所以`FFFF0H`单元中的指令是8086CPU开机后执行的第一条指令

   * DS(Data Segment)：数据段寄存器。CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，而在8086CPU中内存地址由`段地址:偏移地址`组成，而DS寄存器通常就是用来存放要访问的内存单元的段地址。

     指定了内存单元的段地址后可以通过偏移地址，直接对相应的内存单元进行操作用

     > 1. 直接在debua中写入汇编指令可以直接使用`[address]`表示对应的偏移地址为address的内存单元
     > 2. 但是在汇编源程序中，在中括号中直接使用偏移地址需要在前面显式的指定段地址所在的段寄存器，例如：`ds:[0003]`。否则编译器会将方括号中的数据作为常量使用，而不是偏移地址地址
     > 3. 也可以在中括号中使用指定的通用寄存器，例如：`[bx]`或`ds:[bx]`。指示的是段地址为ds中的值，偏移地址是bx寄存器中的值的内存地址。可以显式指定段寄存器，默认是DS。这种显式的指定的段寄存器，在汇编语言中称为**段前缀**
     > 4. 中括号中的通用寄存器应该使用**基地址寄存器BX**
     > 5. 8086CPU不支持将数据直接送入段寄存器的操作，所以当我们要对段寄存器进行操作时需要先将数据送入到一个通用寄存器中，再将通用寄存器中的内容送入段寄存器

   * SS(Stack Segment)：堆栈段寄存器。SS段寄存器和堆栈指针寄存器SP一起指示了当前栈顶在内存中的物理地址。在8086CPU中的任意时刻，`SS:SP`都指向栈顶元素

     8086CPU中栈操作流程：

     1. 入栈流程：
        * 先将堆栈指针寄存器SP中记录的栈顶偏移地址减2，使`SS:SP`指向新的栈顶单元
        * 再将指定的字单元中的数据送入`SS:SP`指向的新的栈顶单元
     2. 出栈流程：
        * 先将`SS:SP`指向的栈顶单元中的数据送入到指定的字单元中
        * 再将堆栈指针寄存器SP中记录的栈顶偏移地址加2，使`SS:SP`指向新的栈顶单元

     > Tips：
     >
     > 1. 8086CPU的栈中每个栈元素大小为一个字(两个内存单元/一个字单元)，每一次栈操作的数据大小也是一个字。**栈操作都是以字为单位**
     > 2. 当栈为空时，栈中没有元素，也就不存在栈顶元素，所以`SS:SP`只能指向栈的最底部内存单元的下面的一个内存单元，而该单元的偏移地址为栈最底部的**字单元**的偏移地址**加2**。

   * ES(Extra Segment)：附加段寄存器。一个备用的段寄存器，常用于显式指定数据段的备用(即DS的备用)

   > 一个程序中使用的程序代码、数据和堆栈各自要用到内存中哪些位置，通过设定段寄存器CS、DS、SS来指向这些起始位置，通常是将DS固定，根据需要修改CS的值

## 字、段、栈

### 1. 字

1. 字的概念：计算机数据的最小单位为字节(byte)，一个字节由8bit组成。一个字(word)由两个字节组成，这两个字节分别为这个字的高位字节和低位字节
2. 字在寄存器里的存储：8086CPU出于对兼容性的考虑，可以一次性处理字节和字两种尺寸的数据。一个字节可以存储在一个8位寄存器里，而一个字可以存储在一个16位寄存器里，而这个字的高位字节和低位字节就存放在这个寄存器的高8位寄存器和低8位寄存器
3. 字在内存中的存储：内存中的一个内存单元是字节单元(一个单元存放一个字节)，所以一个字就需要两个地址连续的内存单元来存放。低位字节存放在低地址内存单元，高位字节存放在高地址内存单元。这个存放一个字型数据(16位)的两个地址连续的内存单元被称为字单元
4. 字的传送：当我们使用mov指令在寄存器和内存中进行字节型数据的传送时，因为8086CPU是16位结构，有16根数据线。所以一次可以传送16位的数据，即一个字。所以当使用mov指令给出的是16位寄存器时就进行的时16位数据的传送

### 2. 段

1. 段是由CPU划分的，而不是内存分段

2. 由于8086CPU使用**基础地址+偏移地址=物理地址**的方式指定物理地址，所以我们可以采用分段的方式对内存进行管理

3. 一个段的起始地址就是它的基础地址，段大小为段中的内存单元个数

4. 在8086CPU中**起始地址(基础地址)=段地址x16**，所以起始地址(基础地址)必定是16的倍数

5. 在8086CPU中偏移地址为16位，16位的寻址能力为64KB，所以一个段的最大长度为64KB

   > Tips：CPU访问某个内存单元时，只要给出的的段地址和偏移地址满足条件都可以访问。即CPU可以通过不同的段地址和偏移地址形成同一个物理地址
   >
   > 在8086CPU中存储单元的地址用段地址和偏移地址这两个元素来描述。如：数据在内存2000:1F60H单元中

### 3. 栈

1. 栈是一种具有特殊访问方式的存储空间，栈具有两种基本操作：入栈和出栈

   > 入栈：将一个新的元素放入栈顶
   >
   > 出栈：从栈顶取出一个元素

2. 当前栈顶的元素总是最后入栈，而最先出栈。这种操作规则被称为：LIFO(Last In First Out)

3. 入栈时，栈顶是从高地址向低地址方向增长的。出栈时，栈顶由低地址向高地址增长

4. 栈顶超界：在8086CPU中没有对栈的栈顶上限和栈底下限进行检查的机制，所以在编程时应注意栈顶超界问题，根据可能用到的最大栈空间进行分配栈的大小，防止入栈数据太多导致栈顶超界；或是栈空后继续出栈导致的超界。但在8086CPU中因为栈空间最大只有64KB(由数据总线宽度决定)所以当栈空间为64KB时发生超界现象，会发生栈顶循环现象，覆盖栈内空间

5. 使用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反

## 物理地址

1. 概念：所有的内存单元构成的存储空间是一个一维的线性空间，而每一个内存单元在这个空间中都有一个唯一的地址，这个唯一地址就被称为物理地址
2. CPU通过地址总线送入存储器的必须是一个内存单元的物理地址，而在CPU向地址总线发出物理地址之前必须先在内部形成这个物理地址，不同CPU形成物理地址的方法不同

## 8086CPU形成物理地址的方法

8086CPU有20位地址总线，可以一次传送20位的地址，寻址能力达到1MB。但8086CPU是16位结构，CPU内部一次性处理、传输、暂存的地址为16位。所以8086CPU采用在内部使用两个16位地址合成的方法形成一个20位的物理地址。

8086CPU读取内存中的指令并执行的简易操作流程如下：(仅从逻辑结构和宏观过程描述，隐藏CPU物理结构和工作细节)

1. CPU中的段寄存器CS提供段地址，指令指针寄存器IP提供偏移地址

2. 段地址和偏移地址通过内部总线送入地址加法器

3. 地址加法器将两个16位地址合成为一个20位的 物理地址

4. 地址加法器通过内部总线将20位的物理地址送入输入输出控制电路

5. 输入输出控制电路将20位的物理地址送上地址总线

6. 对应该物理地址指向的内存单元中读取存放的机器指令

7. 对应的内存单元中存放的机器指令送上数据总线，传送到CPU中的 输入输出控制电路

8. 输入输出控制电路通过内部总线将机器指令送入指令缓冲器

9. 指令指针寄存器IP中的值自动增加读取的机器指令的字节长度

10. 指令缓冲器将机器指令送入执行控制器，执行控制器执行指令

地址加法器生成物理地址的方法是：**物理地址=基础地址(段地址x16)+偏移地址**

## 寻址方式

### 1. 直接寻址

1. 方式：`[idata]`
2. 含义：`EA=idata;SA=(ds)`
3. 常用格式：`[idata]`

### 2. 寄存器间接寻址

1. 方式：`[bx|si|di|bp]`
2. 含义：`EA=(bx|si|di);SA=(ds)`、`EA=(bp);SA=(ss)`
3. 常用格式：`[bx]`

### 3. 寄存器相对寻址

1. 方式：`[bx|si|di|bp+idata]`
2. 含义：`EA=(bx|si|di)+idata;SA=(ds)`、`EA=(bp)+idata;SA=(ss)`
3. 常用格式：
   1. 用于结构体：`[bx].idata`
   2. 用于数组：`idata[si]`、`idata[di]`
   3. 用于二维数组：`[bx][idata]`

### 4. 基址变址寻址

1. 方式：`[bx+si|di]`、`[bp+si|di]`
2. 含义：`EA=(bx)+(si|di);SA=(ds)`、`EA=(bp)+(si|di);SA=(ss)`
3. 常用格式：
   1. 用于二维数组：`[bx][si]`

### 5. 相对基址变址寻址

1. 方式：`[bx+si|di+idata]`、`[bp+si|di+idata]`
2. 含义：`EA=(bx)+(si|di)+idata;SA=(ds)`、`EA=(bp)+(si|di)+idata;SA=(ss)`
3. 常用格式：
   1. 用于表格或结构体中的数组项：`[bx].idata[si]`
   2. 用于二维数组：`idata[bx][si]`

### Tips

1. `bx`和`bp`因为使用的默认段寄存器不同不可同时出现在同一种寻址方式中
2. `si`和`di`作为变址寄存器，除非单独使用。否则只能和`ds`或`bp`寄存器中的一个搭配使用，不能单独使用两个变址寄存器来作为寻址方式
